{"version":3,"sources":["webpack://shared-reducer-frontend/webpack/universalModuleDefinition","webpack://shared-reducer-frontend/webpack/bootstrap","webpack://shared-reducer-frontend/external \"json-immutability-helper\"","webpack://shared-reducer-frontend/./src/actions/actionsHandledCallback.ts","webpack://shared-reducer-frontend/./src/actions/actionsSyncedCallback.ts","webpack://shared-reducer-frontend/./src/WebSocketConnection.ts","webpack://shared-reducer-frontend/./src/index.ts","webpack://shared-reducer-frontend/./src/SharedReducer.ts","webpack://shared-reducer-frontend/./src/lock.ts","webpack://shared-reducer-frontend/./src/idProvider.ts","webpack://shared-reducer-frontend/./src/reduce.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","actionsHandledCallback","callback","state","actionsSyncedCallback","fn","afterSync","WebSocketConnection","constructor","wsUrl","token","messageCallback","errorCallback","this","ws","send","data","queueNextPing","JSON","parse","pingTimeout","clearTimeout","WebSocket","addEventListener","handleMessage","handleError","handleClose","once","message","stringify","close","setTimeout","sendPing","SharedReducer","changeCallback","warningCallback","Map","errorMessage","locked","action","Error","lock","id","idProvider","specs","length","oldState","getState","undefined","pendingChanges","push","applySpecs","currentChange","event","change","nextId","localChanges","currentSyncCallbacks","syncCallbacks","set","connection","index","findIndex","splice","changed","error","latestServerState","update","latestLocalState","callbacks","delete","fixedState","forEach","clear","addSyncCallback","dispatch","localStateFromServerState","serverState","combine","map","forceChangeCallback","delta","dispatchLock","baseChanges","registerSyncCallback","allChanges","aggregate","applyAggregate","combinedChange","initial","cur","vs","prev","next","iterateStack","reduce","syncCallback","curState","sendCurrentChange"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shared-reducer-frontend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shared-reducer-frontend\"] = factory();\n\telse\n\t\troot[\"shared-reducer-frontend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"json-immutability-helper\");","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsHandledCallback<T>(\n  callback?: (state: T) => void,\n): SpecSource<T> {\n  if (!callback) {\n    return null;\n  }\n  return (state: T): null => {\n    callback(state);\n    return null;\n  };\n}\n","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsSyncedCallback<T>(\n  callback?: (state: T) => void,\n): SpecSource<T> {\n  if (!callback) {\n    return null;\n  }\n  const fn = (state: T): void => callback(state);\n  fn.afterSync = true as true;\n  return fn;\n}\n","const PING = 'P';\nconst PONG = 'p';\nconst PING_INTERVAL = 20 * 1000;\n\nfunction getWebSocketClass(): typeof WebSocket {\n  // This condition will disappear at compile time and the function will be inlined;\n  // The output in /build/ always uses WebSocket, never require('ws')\n\n  /* eslint-disable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n  return (process.env.NODE_ENV === 'production') ? WebSocket : require('ws');\n  /* eslint-enable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n}\n\nexport default class WebSocketConnection {\n  private ws: WebSocket;\n\n  private pingTimeout: NodeJS.Timeout | null = null;\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly messageCallback: (message: unknown) => void,\n    private readonly errorCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.ws = new (getWebSocketClass())(wsUrl);\n    this.ws.addEventListener('message', this.handleMessage);\n    this.ws.addEventListener('error', this.handleError);\n    this.ws.addEventListener('close', this.handleClose);\n    if (token) {\n      this.ws.addEventListener('open', () => this.ws.send(token), { once: true });\n    }\n    this.queueNextPing();\n  }\n\n  public send(message: object): void {\n    this.ws.send(JSON.stringify(message));\n  }\n\n  public close(): void {\n    this.ws.close();\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  }\n\n  private queueNextPing(): void {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n    this.pingTimeout = setTimeout(this.sendPing, PING_INTERVAL);\n  }\n\n  private sendPing = (): void => {\n    this.ws.send(PING);\n  };\n\n  private handleMessage = ({ data }: { data: string }): void => {\n    this.queueNextPing();\n    if (data !== PONG) {\n      this.messageCallback(JSON.parse(data));\n    }\n  };\n\n  private handleError = (): void => {\n    this.errorCallback?.('Failed to connect');\n  };\n\n  private handleClose = (): void => {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  };\n}\n","import type { Spec } from 'json-immutability-helper';\nimport type { DispatchSpec, Dispatch } from './DispatchSpec';\nimport actionsHandledCallback from './actions/actionsHandledCallback';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport SharedReducer from './SharedReducer';\n\nexport type { Spec, DispatchSpec, Dispatch };\nexport { actionsHandledCallback, actionsSyncedCallback };\nexport default SharedReducer;\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type {\n  Dispatch,\n  SpecSource,\n  SyncCallback,\n} from './DispatchSpec';\nimport WebSocketConnection from './WebSocketConnection';\nimport reduce from './reduce';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport idProvider from './idProvider';\nimport lock from './lock';\n\ninterface Event<T> {\n  change: Spec<T>;\n  id?: number;\n  error?: undefined;\n}\n\ninterface ApiError {\n  error: string;\n  id?: number;\n}\n\nfunction isError(m: Event<unknown> | ApiError): m is ApiError {\n  return m.error !== undefined;\n}\n\nexport default class SharedReducer<T> {\n  private connection: WebSocketConnection;\n\n  private latestServerState?: T;\n\n  private latestLocalState?: T;\n\n  private currentChange?: Spec<T>;\n\n  private currentSyncCallbacks: SyncCallback<T>[] = [];\n\n  private localChanges: Event<T>[] = [];\n\n  private syncCallbacks = new Map<number, SyncCallback<T>[]>();\n\n  private pendingChanges: SpecSource<T>[] = [];\n\n  private dispatchLock = lock('Cannot dispatch recursively');\n\n  private nextId = idProvider();\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly changeCallback: ((state: T) => void) | undefined = undefined,\n    errorCallback: ((error: string) => void) | undefined = undefined,\n    private readonly warningCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.connection = new WebSocketConnection(\n      wsUrl,\n      token,\n      this.handleMessage,\n      errorCallback,\n    );\n  }\n\n  public close(): void {\n    this.connection.close();\n    this.latestServerState = undefined;\n    this.latestLocalState = undefined;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n    this.localChanges = [];\n    this.syncCallbacks.clear();\n    this.pendingChanges = [];\n  }\n\n  public dispatch: Dispatch<T> = (specs) => {\n    if (!specs || !specs.length) {\n      return;\n    }\n\n    const oldState = this.getState();\n    if (oldState === undefined) {\n      this.pendingChanges.push(...specs);\n    } else {\n      this.applySpecs(oldState, specs, false);\n    }\n  };\n\n  public addSyncCallback(callback: SyncCallback<T>): void {\n    this.dispatch([actionsSyncedCallback(callback)]);\n  }\n\n  public getState(): T | undefined {\n    if (!this.latestLocalState && this.latestServerState) {\n      this.latestLocalState = this.localStateFromServerState(this.latestServerState);\n    }\n    return this.latestLocalState;\n  }\n\n  private localStateFromServerState(serverState: T): T {\n    let state = update(\n      serverState,\n      combine(this.localChanges.map(({ change }) => change)),\n    );\n    if (this.currentChange) {\n      state = update(state, this.currentChange);\n    }\n    return state;\n  }\n\n  private sendCurrentChange = (): void => {\n    if (!this.currentChange) {\n      return;\n    }\n\n    const event = {\n      change: this.currentChange,\n      id: this.nextId(),\n    };\n    this.localChanges.push(event);\n    if (this.currentSyncCallbacks.length > 0) {\n      this.syncCallbacks.set(event.id, this.currentSyncCallbacks);\n      this.currentSyncCallbacks = [];\n    }\n    this.connection.send(event);\n    this.currentChange = undefined;\n  };\n\n  private applySpecs(oldState: T, specs: SpecSource<T>[], forceChangeCallback: boolean): T {\n    const { state, delta } = this.dispatchLock(() => reduce(\n      oldState,\n      specs,\n      (syncCallback, curState) => {\n        if (curState === oldState && !this.currentChange) {\n          syncCallback(oldState);\n        } else {\n          this.currentSyncCallbacks.push(syncCallback);\n        }\n      },\n    ));\n\n    if (state !== oldState) {\n      this.latestLocalState = state;\n      if (!this.currentChange) {\n        this.currentChange = delta;\n        setTimeout(this.sendCurrentChange, 0);\n      } else {\n        this.currentChange = combine<T>([this.currentChange, delta]);\n      }\n    }\n    if (state !== oldState || forceChangeCallback) {\n      this.changeCallback?.(state);\n    }\n    return state;\n  }\n\n  private handleMessage = (data: unknown): void => {\n    const message = data as Event<T> | ApiError;\n\n    const index = (message.id === undefined) ?\n      -1 : this.localChanges.findIndex((c) => (c.id === message.id));\n    if (index !== -1) {\n      this.localChanges.splice(index, 1);\n    }\n\n    let changed = true;\n    if (isError(message)) {\n      this.warningCallback?.(`Update failed: ${message.error}`);\n    } else {\n      if (index === 0) {\n        // removed the oldest pending change and applied it to the base\n        // server state: nothing has changed\n        changed = false;\n      }\n      this.latestServerState = update(\n        this.latestServerState || ({} as T),\n        message.change,\n      );\n    }\n\n    if (changed) {\n      this.latestLocalState = undefined;\n    }\n    let state = this.getState();\n    if (this.pendingChanges.length && state !== undefined) {\n      state = this.applySpecs(state, this.pendingChanges, changed);\n      this.pendingChanges.length = 0;\n    } else if (changed && state !== undefined) {\n      this.changeCallback?.(state);\n    }\n    if (message.id !== undefined) {\n      const callbacks = this.syncCallbacks.get(message.id);\n      if (callbacks) {\n        this.syncCallbacks.delete(message.id);\n        const fixedState = state;\n        if (fixedState === undefined) {\n          throw new Error('Did not receive initial state from server');\n        }\n        callbacks.forEach((fn) => fn(fixedState));\n      }\n    }\n  };\n}\n","export type Lock = <R>(action: () => R) => R;\n\nexport default (errorMessage = 'recursion detected'): Lock => {\n  let locked = false;\n  return <R>(action: () => R): R => {\n    if (locked) {\n      throw new Error(errorMessage);\n    }\n    try {\n      locked = true;\n      return action();\n    } finally {\n      locked = false;\n    }\n  };\n};\n","export type Provider<T> = () => T;\n\nexport default (): Provider<number> => {\n  let id = 0;\n  return (): number => {\n    id += 1;\n    return id;\n  };\n};\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type { SpecSource, SyncCallback } from './DispatchSpec';\n\ninterface StackFrame<T> {\n  vs: T[];\n  i: number;\n  prev: StackFrame<T> | null;\n}\n\nfunction iterateStack<T>(\n  initial: T[],\n  fn: (v: T) => T[] | null | undefined,\n): void {\n  let cur: StackFrame<T> | null = { vs: initial, i: 0, prev: null };\n  while (cur) {\n    if (cur.i >= cur.vs.length) {\n      cur = cur.prev;\n    } else {\n      const next = fn(cur.vs[cur.i]);\n      cur.i += 1;\n      if (next && next.length) {\n        cur = { vs: next, i: 0, prev: cur };\n      }\n    }\n  }\n}\n\ninterface ReductionResult<T> {\n  state: T;\n  delta: Spec<T>;\n}\n\nexport default function reduce<T>(\n  oldState: T,\n  baseChanges: SpecSource<T>[],\n  registerSyncCallback: (fn: SyncCallback<T>, currentState: T) => void,\n): ReductionResult<T> {\n  let state: T = oldState;\n\n  const allChanges: Spec<T>[] = [];\n  const aggregate: Spec<T>[] = [];\n  function applyAggregate(): void {\n    if (aggregate.length > 0) {\n      const combinedChange = combine<T>(aggregate);\n      allChanges.push(combinedChange);\n      state = update(state, combinedChange);\n      aggregate.length = 0;\n    }\n  }\n\n  iterateStack(baseChanges, (change) => {\n    if (typeof change === 'function') {\n      applyAggregate();\n      if (change.afterSync) {\n        registerSyncCallback(change, state);\n        return null;\n      }\n      return change(oldState);\n    }\n    if (change) {\n      aggregate.push(change);\n    }\n    return null;\n  });\n  applyAggregate();\n  return { state, delta: combine<T>(allChanges) };\n}\n"],"sourceRoot":""}