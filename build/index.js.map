{"version":3,"sources":["webpack://shared-reducer-frontend/webpack/universalModuleDefinition","webpack://shared-reducer-frontend/webpack/bootstrap","webpack://shared-reducer-frontend/external \"json-immutability-helper\"","webpack://shared-reducer-frontend/./src/actions/actionsHandledCallback.ts","webpack://shared-reducer-frontend/./src/actions/actionsSyncedCallback.ts","webpack://shared-reducer-frontend/./src/WebSocketConnection.ts","webpack://shared-reducer-frontend/./src/index.ts","webpack://shared-reducer-frontend/./src/SharedReducer.ts","webpack://shared-reducer-frontend/./src/lock.ts","webpack://shared-reducer-frontend/./src/idProvider.ts","webpack://shared-reducer-frontend/./src/reduce.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","actionsHandledCallback","callback","state","actionsSyncedCallback","resolve","reject","fn","afterSync","WebSocketConnection","constructor","wsUrl","token","messageCallback","errorCallback","this","ws","send","data","queueNextPing","JSON","parse","pingTimeout","clearTimeout","WebSocket","addEventListener","handleMessage","handleError","handleClose","once","message","stringify","close","setTimeout","sendPing","SharedReducer","changeCallback","warningCallback","errorMessage","locked","action","Error","lock","id","idProvider","specs","length","oldState","getState","undefined","pendingChanges","push","applySpecs","currentChange","nextId","change","syncCallbacks","currentSyncCallbacks","localChanges","connection","localChange","index","popLocalChange","error","latestLocalState","forEach","changedOrder","latestServerState","update","localStateFromServerState","addSyncCallback","dispatch","syncedState","Promise","serverState","combine","map","addCurrentChange","spec","sendCurrentChange","forceChangeCallback","delta","dispatchLock","baseChanges","registerSyncCallback","allChanges","aggregate","applyAggregate","combinedChange","initial","cur","vs","prev","next","iterateStack","reduce","syncCallback","curState","findIndex","splice"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shared-reducer-frontend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shared-reducer-frontend\"] = factory();\n\telse\n\t\troot[\"shared-reducer-frontend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"json-immutability-helper\");","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsHandledCallback<T>(\n  callback?: (state: T) => void,\n): SpecSource<T> {\n  if (!callback) {\n    return null;\n  }\n  return (state: T): null => {\n    callback(state);\n    return null;\n  };\n}\n","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsSyncedCallback<T>(\n  resolve?: (state: T) => void,\n  reject?: (message: string) => void,\n): SpecSource<T> {\n  if (!resolve && !reject) {\n    return null;\n  }\n  const fn = (state: T): void => resolve?.(state);\n  fn.reject = reject;\n  fn.afterSync = true as const;\n  return fn;\n}\n","const PING = 'P';\nconst PONG = 'p';\nconst PING_INTERVAL = 20 * 1000;\n\nfunction getWebSocketClass(): typeof WebSocket {\n  // This condition will disappear at compile time and the function will be inlined;\n  // The output in /build/ always uses WebSocket, never require('ws')\n\n  /* eslint-disable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n  return (process.env.NODE_ENV === 'production') ? WebSocket : require('ws');\n  /* eslint-enable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n}\n\nexport default class WebSocketConnection {\n  private ws: WebSocket;\n\n  private pingTimeout: NodeJS.Timeout | null = null;\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly messageCallback: (message: unknown) => void,\n    private readonly errorCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.ws = new (getWebSocketClass())(wsUrl);\n    this.ws.addEventListener('message', this.handleMessage);\n    this.ws.addEventListener('error', this.handleError);\n    this.ws.addEventListener('close', this.handleClose);\n    if (token) {\n      this.ws.addEventListener('open', () => this.ws.send(token), { once: true });\n    }\n    this.queueNextPing();\n  }\n\n  public send(message: unknown): void {\n    this.ws.send(JSON.stringify(message));\n  }\n\n  public close(): void {\n    this.ws.close();\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  }\n\n  private queueNextPing(): void {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n    this.pingTimeout = setTimeout(this.sendPing, PING_INTERVAL);\n  }\n\n  private sendPing = (): void => {\n    this.ws.send(PING);\n  };\n\n  private handleMessage = ({ data }: { data: string }): void => {\n    this.queueNextPing();\n    if (data !== PONG) {\n      this.messageCallback(JSON.parse(data));\n    }\n  };\n\n  private handleError = (): void => {\n    this.errorCallback?.('Failed to connect');\n  };\n\n  private handleClose = (): void => {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  };\n}\n","import type { Spec } from 'json-immutability-helper';\nimport type { DispatchSpec, Dispatch } from './DispatchSpec';\nimport actionsHandledCallback from './actions/actionsHandledCallback';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport SharedReducer from './SharedReducer';\n\nexport type { Spec, DispatchSpec, Dispatch };\nexport { actionsHandledCallback, actionsSyncedCallback };\nexport default SharedReducer;\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type {\n  Dispatch,\n  SpecSource,\n  SyncCallback,\n} from './DispatchSpec';\nimport WebSocketConnection from './WebSocketConnection';\nimport reduce from './reduce';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport idProvider from './idProvider';\nimport lock from './lock';\n\ninterface Event<T> {\n  change: Spec<T>;\n  id?: number;\n  error?: undefined;\n}\n\ninterface LocalChange<T> {\n  change: Spec<T>;\n  id: number;\n  syncCallbacks: SyncCallback<T>[];\n}\n\ninterface LocalChangeIndex<T> {\n  localChange: LocalChange<T> | null;\n  index: number;\n}\n\ninterface ApiError {\n  error: string;\n  id?: number;\n}\n\nfunction isError(m: Event<unknown> | ApiError): m is ApiError {\n  return m.error !== undefined;\n}\n\nexport default class SharedReducer<T> {\n  private connection: WebSocketConnection;\n\n  private latestServerState?: T;\n\n  private latestLocalState?: T;\n\n  private currentChange?: Spec<T>;\n\n  private currentSyncCallbacks: SyncCallback<T>[] = [];\n\n  private localChanges: LocalChange<T>[] = [];\n\n  private pendingChanges: SpecSource<T>[] = [];\n\n  private dispatchLock = lock('Cannot dispatch recursively');\n\n  private nextId = idProvider();\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly changeCallback: ((state: T) => void) | undefined = undefined,\n    errorCallback: ((error: string) => void) | undefined = undefined,\n    private readonly warningCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.connection = new WebSocketConnection(\n      wsUrl,\n      token,\n      this.handleMessage,\n      errorCallback,\n    );\n  }\n\n  public close(): void {\n    this.connection.close();\n    this.latestServerState = undefined;\n    this.latestLocalState = undefined;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n    this.localChanges = [];\n    this.pendingChanges = [];\n  }\n\n  public dispatch: Dispatch<T> = (specs) => {\n    if (!specs || !specs.length) {\n      return;\n    }\n\n    const oldState = this.getState();\n    if (oldState === undefined) {\n      this.pendingChanges.push(...specs);\n    } else {\n      this.applySpecs(oldState, specs, false);\n    }\n  };\n\n  public addSyncCallback(\n    resolve: (state: T) => void,\n    reject?: (message: string) => void,\n  ): void {\n    this.dispatch([actionsSyncedCallback(resolve, reject)]);\n  }\n\n  public syncedState(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.addSyncCallback(resolve, reject);\n    });\n  }\n\n  public getState(): T | undefined {\n    if (!this.latestLocalState && this.latestServerState) {\n      this.latestLocalState = this.localStateFromServerState(this.latestServerState);\n    }\n    return this.latestLocalState;\n  }\n\n  private localStateFromServerState(serverState: T): T {\n    let state = update(\n      serverState,\n      combine(this.localChanges.map(({ change }) => change)),\n    );\n    if (this.currentChange) {\n      state = update(state, this.currentChange);\n    }\n    return state;\n  }\n\n  private sendCurrentChange = (): void => {\n    if (!this.currentChange) {\n      return;\n    }\n\n    const id = this.nextId();\n    const change = this.currentChange;\n    const syncCallbacks = this.currentSyncCallbacks;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n\n    this.localChanges.push({ change, id, syncCallbacks });\n    this.connection.send({ change, id });\n  };\n\n  private addCurrentChange(spec: Spec<T>): void {\n    if (!this.currentChange) {\n      this.currentChange = spec;\n      setTimeout(this.sendCurrentChange, 0);\n    } else {\n      this.currentChange = combine<T>([this.currentChange, spec]);\n    }\n  }\n\n  private applySpecs(oldState: T, specs: SpecSource<T>[], forceChangeCallback: boolean): T {\n    if (!specs.length) { // optimisation for pendingChanges\n      if (forceChangeCallback) {\n        this.changeCallback?.(oldState);\n      }\n      return oldState;\n    }\n\n    const { state, delta } = this.dispatchLock(() => reduce(\n      oldState,\n      specs,\n      (syncCallback, curState) => {\n        if (curState === oldState && !this.currentChange) {\n          syncCallback(oldState);\n        } else {\n          this.currentSyncCallbacks.push(syncCallback);\n        }\n      },\n    ));\n\n    if (state !== oldState) {\n      this.latestLocalState = state;\n      this.addCurrentChange(delta);\n    }\n    if (state !== oldState || forceChangeCallback) {\n      this.changeCallback?.(state);\n    }\n    return state;\n  }\n\n  private popLocalChange(id: number | undefined): LocalChangeIndex<T> {\n    const index = (id === undefined) ? -1 : this.localChanges.findIndex((c) => (c.id === id));\n    if (index === -1) {\n      return { localChange: null, index };\n    }\n    return {\n      localChange: this.localChanges.splice(index, 1)[0],\n      index,\n    };\n  }\n\n  private handleMessage = (data: unknown): void => {\n    const message = data as Event<T> | ApiError;\n\n    const { localChange, index } = this.popLocalChange(message.id);\n\n    if (isError(message)) {\n      this.warningCallback?.(`Update failed: ${message.error}`);\n      this.latestLocalState = undefined;\n      const state = this.getState();\n      if (state) {\n        this.changeCallback?.(state);\n      }\n      localChange?.syncCallbacks.forEach((fn) => fn.reject?.(message.error));\n      return;\n    }\n\n    // if first, removed the oldest pending change and applied it to\n    // the base server state: nothing has changed\n    const changedOrder = (index !== 0);\n\n    this.latestServerState = update(this.latestServerState || ({} as T), message.change);\n\n    if (!this.latestLocalState || changedOrder) {\n      this.latestLocalState = this.localStateFromServerState(this.latestServerState);\n    }\n    let state = this.latestLocalState;\n    state = this.applySpecs(state, this.pendingChanges, changedOrder);\n    this.pendingChanges.length = 0;\n    localChange?.syncCallbacks.forEach((fn) => fn(state));\n  };\n}\n","export type Lock = <R>(action: () => R) => R;\n\nexport default (errorMessage: string): Lock => {\n  let locked = false;\n  return <R>(action: () => R): R => {\n    if (locked) {\n      throw new Error(errorMessage);\n    }\n    try {\n      locked = true;\n      return action();\n    } finally {\n      locked = false;\n    }\n  };\n};\n","export type Provider<T> = () => T;\n\nexport default (): Provider<number> => {\n  let id = 0;\n  return (): number => {\n    id += 1;\n    return id;\n  };\n};\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type { SpecSource, SyncCallback } from './DispatchSpec';\n\ninterface StackFrame<T> {\n  vs: T[];\n  i: number;\n  prev: StackFrame<T> | null;\n}\n\nfunction iterateStack<T>(\n  initial: T[],\n  fn: (v: T) => T[] | null | undefined,\n): void {\n  let cur: StackFrame<T> | null = { vs: initial, i: 0, prev: null };\n  while (cur) {\n    if (cur.i >= cur.vs.length) {\n      cur = cur.prev;\n    } else {\n      const next = fn(cur.vs[cur.i]);\n      cur.i += 1;\n      if (next && next.length) {\n        cur = { vs: next, i: 0, prev: cur };\n      }\n    }\n  }\n}\n\ninterface ReductionResult<T> {\n  state: T;\n  delta: Spec<T>;\n}\n\nexport default function reduce<T>(\n  oldState: T,\n  baseChanges: SpecSource<T>[],\n  registerSyncCallback: (fn: SyncCallback<T>, currentState: T) => void,\n): ReductionResult<T> {\n  let state: T = oldState;\n\n  const allChanges: Spec<T>[] = [];\n  const aggregate: Spec<T>[] = [];\n  function applyAggregate(): void {\n    if (aggregate.length > 0) {\n      const combinedChange = combine<T>(aggregate);\n      allChanges.push(combinedChange);\n      state = update(state, combinedChange);\n      aggregate.length = 0;\n    }\n  }\n\n  iterateStack(baseChanges, (change) => {\n    if (typeof change === 'function') {\n      applyAggregate();\n      if (change.afterSync) {\n        registerSyncCallback(change, state);\n        return null;\n      }\n      return change(state);\n    }\n    if (change) {\n      aggregate.push(change);\n    }\n    return null;\n  });\n  applyAggregate();\n  return { state, delta: combine<T>(allChanges) };\n}\n"],"sourceRoot":""}