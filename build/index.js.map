{"version":3,"sources":["webpack://shared-reducer-frontend/webpack/universalModuleDefinition","webpack://shared-reducer-frontend/webpack/bootstrap","webpack://shared-reducer-frontend/./src/actions/actionsHandledCallback.ts","webpack://shared-reducer-frontend/./src/DispatchSpec.ts","webpack://shared-reducer-frontend/./src/actions/actionsSyncedCallback.ts","webpack://shared-reducer-frontend/./src/WebSocketConnection.ts","webpack://shared-reducer-frontend/./src/SharedReducer.ts","webpack://shared-reducer-frontend/./src/lock.ts","webpack://shared-reducer-frontend/./src/idProvider.ts","webpack://shared-reducer-frontend/./src/reduce.ts","webpack://shared-reducer-frontend/./src/index.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","actionsHandledCallback","callback","state","SyncCallback","constructor","sync","reject","NOP","actionsSyncedCallback","resolve","WebSocketConnection","wsUrl","token","messageCallback","errorCallback","this","ws","send","data","queueNextPing","JSON","parse","pingTimeout","clearTimeout","WebSocket","addEventListener","handleMessage","handleError","handleClose","once","message","stringify","close","setTimeout","sendPing","SharedReducer","context","changeHandler","errorHandler","warningHandler","errorMessage","locked","action","Error","lock","id","idProvider","specs","length","latestStates","updatedState","applySpecs","local","pendingChanges","push","undefined","currentChange","nextId","change","syncCallbacks","currentSyncCallbacks","localChanges","connection","handleChangeMessage","handleInitMessage","handleErrorMessage","bContext","bToken","bErrorHandler","bWarningHandler","builder","withReducer","withToken","withErrorHandler","handler","withWarningHandler","build","addSyncCallback","dispatch","syncedState","Promise","getState","addCurrentChange","spec","sendCurrentChange","combine","old","delta","dispatchLock","oldState","baseChanges","registerSyncCallback","allChanges","aggregate","applyAggregate","combinedChange","update","initial","fn","cur","vs","prev","next","iterateStack","reduce","syncCallback","curState","server","popLocalChange","index","findIndex","localChange","splice","error","computeLocal","forEach","init","changes","map"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shared-reducer-frontend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shared-reducer-frontend\"] = factory();\n\telse\n\t\troot[\"shared-reducer-frontend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function actionsHandledCallback<T>(\n  callback?: (state: T) => void,\n): ((state: T) => null) | null {\n  if (!callback) {\n    return null;\n  }\n  return (state: T): null => {\n    callback(state);\n    return null;\n  };\n}\n","export interface Context<T, SpecT> {\n  update: (input: T, spec: SpecT) => T;\n  combine: (specs: SpecT[]) => SpecT;\n}\n\nexport class SyncCallback<T> {\n  constructor(\n    public readonly sync: (state: T) => void,\n    public readonly reject: (message: string) => void,\n  ) {}\n}\nexport type SpecGenerator<T, SpecT> = (state: T) => SpecSource<T, SpecT>[] | null | undefined;\nexport type SpecSource<T, SpecT> = (\n  SpecT |\n  SpecGenerator<T, SpecT> |\n  SyncCallback<T> |\n  null |\n  undefined\n);\n\nexport type DispatchSpec<T, SpecT> = SpecSource<T, SpecT>[];\nexport type Dispatch<T, SpecT> = (specs: DispatchSpec<T, SpecT> | null | undefined) => void;\n","import { SyncCallback } from '../DispatchSpec';\n\nconst NOP = (): null => null;\n\nexport default function actionsSyncedCallback<T>(\n  resolve?: (state: T) => void,\n  reject?: (message: string) => void,\n): SyncCallback<T> | null {\n  if (!resolve && !reject) {\n    return null;\n  }\n  return new SyncCallback(resolve || NOP, reject || NOP);\n}\n","const PING = 'P';\nconst PONG = 'p';\nconst PING_INTERVAL = 20 * 1000;\n\nfunction getWebSocketClass(): typeof WebSocket {\n  // This condition will disappear at compile time and the function will be inlined;\n  // The output in /build/ always uses WebSocket, never require('ws')\n\n  /* eslint-disable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n  return (process.env.NODE_ENV === 'production') ? WebSocket : require('ws');\n  /* eslint-enable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n}\n\nexport default class WebSocketConnection {\n  private ws: WebSocket;\n\n  private pingTimeout: NodeJS.Timeout | null = null;\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly messageCallback: (message: unknown) => void,\n    private readonly errorCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.ws = new (getWebSocketClass())(wsUrl);\n    this.ws.addEventListener('message', this.handleMessage);\n    this.ws.addEventListener('error', this.handleError);\n    this.ws.addEventListener('close', this.handleClose);\n    if (token) {\n      this.ws.addEventListener('open', () => this.ws.send(token), { once: true });\n    }\n    this.queueNextPing();\n  }\n\n  public send(message: unknown): void {\n    this.ws.send(JSON.stringify(message));\n  }\n\n  public close(): void {\n    this.ws.close();\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  }\n\n  private queueNextPing(): void {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n    this.pingTimeout = setTimeout(this.sendPing, PING_INTERVAL);\n  }\n\n  private sendPing = (): void => {\n    this.ws.send(PING);\n  };\n\n  private handleMessage = ({ data }: { data: string }): void => {\n    this.queueNextPing();\n    if (data !== PONG) {\n      this.messageCallback(JSON.parse(data));\n    }\n  };\n\n  private handleError = (): void => {\n    this.errorCallback?.('Failed to connect');\n  };\n\n  private handleClose = (): void => {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  };\n}\n","import type {\n  Context,\n  Dispatch,\n  SpecSource,\n  SyncCallback,\n} from './DispatchSpec';\nimport WebSocketConnection from './WebSocketConnection';\nimport reduce from './reduce';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport idProvider from './idProvider';\nimport lock from './lock';\n\ninterface InitEvent<T> {\n  init: T;\n  id?: undefined;\n}\n\ninterface ChangeEvent<SpecT> {\n  change: SpecT;\n  id?: number;\n}\n\ninterface LocalChange<T, SpecT> {\n  change: SpecT;\n  id: number;\n  syncCallbacks: SyncCallback<T>[];\n}\n\ninterface LocalChangeIndex<T, SpecT> {\n  localChange: LocalChange<T, SpecT> | null;\n  index: number;\n}\n\ninterface ApiError {\n  error: string;\n  id?: number;\n}\n\ninterface State<T> {\n  readonly server: T;\n  readonly local: T;\n}\n\ninterface SharedReducerBuilder<T, SpecT> {\n  withReducer<SpecT2 extends SpecT>(\n    context: Context<T, SpecT2>,\n  ): SharedReducerBuilder<T, SpecT2>;\n\n  withToken(token: string): this;\n\n  withErrorHandler(handler: (error: string) => void): this;\n\n  withWarningHandler(handler: (error: string) => void): this;\n\n  build(): SharedReducer<T, SpecT>;\n}\n\nexport default class SharedReducer<T, SpecT> {\n  private connection: WebSocketConnection;\n\n  private latestStates: State<T> | null = null;\n\n  private currentChange?: SpecT;\n\n  private currentSyncCallbacks: SyncCallback<T>[] = [];\n\n  private localChanges: LocalChange<T, SpecT>[] = [];\n\n  private pendingChanges: SpecSource<T, SpecT>[] = [];\n\n  private dispatchLock = lock('Cannot dispatch recursively');\n\n  private nextId = idProvider();\n\n  private constructor(\n    private readonly context: Context<T, SpecT>,\n    wsUrl: string,\n    token: string | undefined,\n    private readonly changeHandler: ((state: T) => void) | undefined,\n    errorHandler: ((error: string) => void) | undefined,\n    private readonly warningHandler: ((error: string) => void) | undefined,\n  ) {\n    this.connection = new WebSocketConnection(\n      wsUrl,\n      token,\n      this.handleMessage,\n      errorHandler,\n    );\n  }\n\n  public static for<T2>(\n    wsUrl: string,\n    changeHandler?: (state: T2) => void,\n  ): SharedReducerBuilder<T2, unknown> {\n    let bContext: Context<T2, unknown>;\n    let bToken: string;\n    let bErrorHandler: (error: string) => void;\n    let bWarningHandler: (error: string) => void;\n\n    // return types are defined in SharedReducerBuilder interface */\n    /* eslint-disable @typescript-eslint/explicit-function-return-type */\n    const builder = {\n      withReducer(context: Context<T2, unknown>) {\n        bContext = context;\n        return builder;\n      },\n\n      withToken(token: string) {\n        bToken = token;\n        return builder;\n      },\n\n      withErrorHandler(handler: (error: string) => void) {\n        bErrorHandler = handler;\n        return builder;\n      },\n\n      withWarningHandler(handler: (error: string) => void) {\n        bWarningHandler = handler;\n        return builder;\n      },\n\n      build() {\n        if (!bContext) {\n          throw new Error('must set broadcaster context');\n        }\n        return new SharedReducer(\n          bContext,\n          wsUrl,\n          bToken,\n          changeHandler,\n          bErrorHandler,\n          bWarningHandler,\n        );\n      },\n    };\n    return builder as SharedReducerBuilder<T2, unknown>;\n  }\n\n  public close(): void {\n    this.connection.close();\n    this.latestStates = null;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n    this.localChanges = [];\n    this.pendingChanges = [];\n  }\n\n  public dispatch: Dispatch<T, SpecT> = (specs) => {\n    if (!specs || !specs.length) {\n      return;\n    }\n\n    if (this.latestStates) {\n      const updatedState = this.applySpecs(this.latestStates, specs);\n      if (updatedState !== this.latestStates) {\n        this.latestStates = updatedState;\n        this.changeHandler?.(updatedState.local);\n      }\n    } else {\n      this.pendingChanges.push(...specs);\n    }\n  };\n\n  public addSyncCallback(\n    resolve: (state: T) => void,\n    reject?: (message: string) => void,\n  ): void {\n    this.dispatch([actionsSyncedCallback(resolve, reject)]);\n  }\n\n  public syncedState(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.addSyncCallback(resolve, reject);\n    });\n  }\n\n  public getState(): T | undefined {\n    return this.latestStates?.local;\n  }\n\n  private sendCurrentChange = (): void => {\n    if (this.currentChange === undefined) {\n      return;\n    }\n\n    const id = this.nextId();\n    const change = this.currentChange;\n    const syncCallbacks = this.currentSyncCallbacks;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n\n    this.localChanges.push({ change, id, syncCallbacks });\n    this.connection.send({ change, id });\n  };\n\n  private addCurrentChange(spec: SpecT): void {\n    if (this.currentChange === undefined) {\n      this.currentChange = spec;\n      setTimeout(this.sendCurrentChange, 0);\n    } else {\n      this.currentChange = this.context.combine([this.currentChange, spec]);\n    }\n  }\n\n  private applySpecs(old: State<T>, specs: SpecSource<T, SpecT>[]): State<T> {\n    if (!specs.length) { // optimisation for pendingChanges\n      return old;\n    }\n\n    const { state, delta } = this.dispatchLock(() => reduce(\n      this.context,\n      old.local,\n      specs,\n      (syncCallback, curState) => {\n        if (curState === old.local && this.currentChange === undefined) {\n          syncCallback.sync(old.local);\n        } else {\n          this.currentSyncCallbacks.push(syncCallback);\n        }\n      },\n    ));\n\n    if (state === old.local) {\n      return old;\n    }\n\n    this.addCurrentChange(delta);\n    return {\n      server: old.server,\n      local: state,\n    };\n  }\n\n  private popLocalChange(id: number | undefined): LocalChangeIndex<T, SpecT> {\n    const index = (id === undefined) ? -1 : this.localChanges.findIndex((c) => (c.id === id));\n    if (index === -1) {\n      return { localChange: null, index };\n    }\n    return {\n      localChange: this.localChanges.splice(index, 1)[0],\n      index,\n    };\n  }\n\n  private handleErrorMessage(message: ApiError): void {\n    const { localChange } = this.popLocalChange(message.id);\n    if (!localChange) {\n      this.warningHandler?.(`API sent error: ${message.error}`);\n      return;\n    }\n    this.warningHandler?.(`API rejected update: ${message.error}`);\n    if (this.latestStates) {\n      this.latestStates = this.computeLocal(this.latestStates.server);\n      this.changeHandler?.(this.latestStates.local);\n    }\n    localChange.syncCallbacks.forEach((fn) => fn.reject(message.error));\n  }\n\n  private handleInitMessage(message: InitEvent<T>): void {\n    this.latestStates = this.applySpecs(this.computeLocal(message.init), this.pendingChanges);\n    this.pendingChanges.length = 0;\n    this.changeHandler?.(this.latestStates.local);\n  }\n\n  private handleChangeMessage(message: ChangeEvent<SpecT>): void {\n    if (!this.latestStates) {\n      this.warningHandler?.(`Ignoring change before init: ${JSON.stringify(message)}`);\n      return;\n    }\n\n    const { localChange, index } = this.popLocalChange(message.id);\n\n    const server = this.context.update(this.latestStates.server, message.change);\n\n    if (index === 0) {\n      // just removed the oldest pending change and applied it to\n      // the base server state: nothing has changed\n      this.latestStates = { server, local: this.latestStates.local };\n    } else {\n      this.latestStates = this.computeLocal(server);\n      this.changeHandler?.(this.latestStates.local);\n    }\n    const state = this.latestStates.local;\n    localChange?.syncCallbacks.forEach((callback) => callback.sync(state));\n  }\n\n  private handleMessage = (message: unknown): void => {\n    if (Object.prototype.hasOwnProperty.call(message, 'change')) {\n      this.handleChangeMessage(message as ChangeEvent<SpecT>);\n    } else if (Object.prototype.hasOwnProperty.call(message, 'init')) {\n      this.handleInitMessage(message as InitEvent<T>);\n    } else if (Object.prototype.hasOwnProperty.call(message, 'error')) {\n      this.handleErrorMessage(message as ApiError);\n    } else {\n      this.warningHandler?.(`Ignoring unknown API message: ${JSON.stringify(message)}`);\n    }\n  };\n\n  private computeLocal(server: T): State<T> {\n    let local = server;\n    if (this.localChanges.length > 0) {\n      const changes = this.context.combine(this.localChanges.map(({ change }) => change));\n      local = this.context.update(local, changes);\n    }\n    if (this.currentChange !== undefined) {\n      local = this.context.update(local, this.currentChange);\n    }\n    return { server, local };\n  }\n}\n","export type Lock = <R>(action: () => R) => R;\n\nexport default (errorMessage: string): Lock => {\n  let locked = false;\n  return <R>(action: () => R): R => {\n    if (locked) {\n      throw new Error(errorMessage);\n    }\n    try {\n      locked = true;\n      return action();\n    } finally {\n      locked = false;\n    }\n  };\n};\n","export type Provider<T> = () => T;\n\nexport default (): Provider<number> => {\n  let id = 0;\n  return (): number => {\n    id += 1;\n    return id;\n  };\n};\n","import {\n  Context,\n  SpecGenerator,\n  SpecSource,\n  SyncCallback,\n} from './DispatchSpec';\n\ninterface StackFrame<T> {\n  vs: T[];\n  i: number;\n  prev: StackFrame<T> | null;\n}\n\nfunction iterateStack<T>(\n  initial: T[],\n  fn: (v: T) => T[] | null | undefined,\n): void {\n  let cur: StackFrame<T> | null = { vs: initial, i: 0, prev: null };\n  while (cur) {\n    if (cur.i >= cur.vs.length) {\n      cur = cur.prev;\n    } else {\n      const next = fn(cur.vs[cur.i]);\n      cur.i += 1;\n      if (next && next.length) {\n        cur = { vs: next, i: 0, prev: cur };\n      }\n    }\n  }\n}\n\ninterface ReductionResult<T, SpecT> {\n  state: T;\n  delta: SpecT;\n}\n\nexport default function reduce<T, SpecT>(\n  context: Context<T, SpecT>,\n  oldState: T,\n  baseChanges: SpecSource<T, SpecT>[],\n  registerSyncCallback: (fn: SyncCallback<T>, currentState: T) => void,\n): ReductionResult<T, SpecT> {\n  let state: T = oldState;\n\n  const allChanges: SpecT[] = [];\n  const aggregate: SpecT[] = [];\n  function applyAggregate(): void {\n    if (aggregate.length > 0) {\n      const combinedChange = context.combine(aggregate);\n      allChanges.push(combinedChange);\n      state = context.update(state, combinedChange);\n      aggregate.length = 0;\n    }\n  }\n\n  iterateStack(baseChanges, (change) => {\n    if (change instanceof SyncCallback) {\n      applyAggregate();\n      registerSyncCallback(change, state);\n      return null;\n    }\n    if (typeof change === 'function') {\n      applyAggregate();\n      const generator = change as SpecGenerator<T, SpecT>;\n      return generator(state);\n    }\n    if (change) {\n      aggregate.push(change);\n    }\n    return null;\n  });\n  applyAggregate();\n  return { state, delta: context.combine(allChanges) };\n}\n","import type { DispatchSpec, Dispatch, Context } from './DispatchSpec';\nimport actionsHandledCallback from './actions/actionsHandledCallback';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport SharedReducer from './SharedReducer';\n\nexport type { DispatchSpec, Dispatch, Context };\nexport { actionsHandledCallback, actionsSyncedCallback };\nexport default SharedReducer;\n"],"sourceRoot":""}