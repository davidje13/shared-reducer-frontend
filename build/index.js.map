{"version":3,"sources":["webpack://shared-reducer-frontend/webpack/universalModuleDefinition","webpack://shared-reducer-frontend/webpack/bootstrap","webpack://shared-reducer-frontend/external \"json-immutability-helper\"","webpack://shared-reducer-frontend/./src/actions/actionsHandledCallback.ts","webpack://shared-reducer-frontend/./src/actions/actionsSyncedCallback.ts","webpack://shared-reducer-frontend/./src/WebSocketConnection.ts","webpack://shared-reducer-frontend/./src/index.ts","webpack://shared-reducer-frontend/./src/SharedReducer.ts","webpack://shared-reducer-frontend/./src/reduce.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","actionsHandledCallback","callback","state","actionsSyncedCallback","fn","afterSync","WebSocketConnection","constructor","wsUrl","token","messageCallback","errorCallback","this","ws","send","data","queueNextPing","JSON","parse","pingTimeout","clearTimeout","WebSocket","addEventListener","handleMessage","handleError","handleClose","once","message","stringify","close","setTimeout","sendPing","SharedReducer","changeCallback","warningCallback","Map","specs","length","isDispatching","Error","oldState","getState","undefined","pendingChanges","push","internalApply","currentChange","event","change","id","internalGetUniqueId","localChanges","currentSyncCallbacks","syncCallbacks","set","connection","index","findIndex","splice","changed","error","latestServerState","update","latestLocalState","newState","callbacks","delete","fixedState","forEach","clear","addSyncCallback","dispatch","internalLocalStateFromServerState","serverState","combine","map","idCounter","changes","delta","baseChanges","registerSyncCallback","allChanges","aggregate","applyAggregate","combinedChange","initial","cur","vs","prev","next","iterateStack","reduce","syncCallback","curState","internalSend"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shared-reducer-frontend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shared-reducer-frontend\"] = factory();\n\telse\n\t\troot[\"shared-reducer-frontend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"json-immutability-helper\");","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsHandledCallback<T>(\n  callback?: (state: T) => void,\n): SpecSource<T> {\n  if (!callback) {\n    return null;\n  }\n  return (state: T): null => {\n    callback(state);\n    return null;\n  };\n}\n","import type { SpecSource } from '../DispatchSpec';\n\nexport default function actionsSyncedCallback<T>(\n  callback?: (state: T) => void,\n): SpecSource<T> {\n  if (!callback) {\n    return null;\n  }\n  const fn = (state: T): void => callback(state);\n  fn.afterSync = true as true;\n  return fn;\n}\n","const PING = 'P';\nconst PONG = 'p';\nconst PING_INTERVAL = 20 * 1000;\n\nfunction getWebSocketClass(): typeof WebSocket {\n  // This condition will disappear at compile time and the function will be inlined;\n  // The output in /build/ always uses WebSocket, never require('ws')\n\n  /* eslint-disable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n  return (process.env.NODE_ENV === 'production') ? WebSocket : require('ws');\n  /* eslint-enable\n       import/no-extraneous-dependencies,\n       @typescript-eslint/no-require-imports,\n       global-require\n  */\n}\n\nexport default class WebSocketConnection {\n  private ws: WebSocket;\n\n  private pingTimeout: NodeJS.Timeout | null = null;\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly messageCallback: (message: unknown) => void,\n    private readonly errorCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.ws = new (getWebSocketClass())(wsUrl);\n    this.ws.addEventListener('message', this.handleMessage);\n    this.ws.addEventListener('error', this.handleError);\n    this.ws.addEventListener('close', this.handleClose);\n    if (token) {\n      this.ws.addEventListener('open', () => this.ws.send(token), { once: true });\n    }\n    this.queueNextPing();\n  }\n\n  public send(message: object): void {\n    this.ws.send(JSON.stringify(message));\n  }\n\n  public close(): void {\n    this.ws.close();\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  }\n\n  private queueNextPing(): void {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n    this.pingTimeout = setTimeout(this.sendPing, PING_INTERVAL);\n  }\n\n  private sendPing = (): void => {\n    this.ws.send(PING);\n  };\n\n  private handleMessage = ({ data }: { data: string }): void => {\n    this.queueNextPing();\n    if (data !== PONG) {\n      this.messageCallback(JSON.parse(data));\n    }\n  };\n\n  private handleError = (): void => {\n    this.errorCallback?.('Failed to connect');\n  };\n\n  private handleClose = (): void => {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n    }\n  };\n}\n","import type { Spec } from 'json-immutability-helper';\nimport type { DispatchSpec, Dispatch } from './DispatchSpec';\nimport actionsHandledCallback from './actions/actionsHandledCallback';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\nimport SharedReducer from './SharedReducer';\n\nexport type { Spec, DispatchSpec, Dispatch };\nexport { actionsHandledCallback, actionsSyncedCallback };\nexport default SharedReducer;\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type {\n  Dispatch,\n  SpecSource,\n  SyncCallback,\n} from './DispatchSpec';\nimport WebSocketConnection from './WebSocketConnection';\nimport reduce from './reduce';\nimport actionsSyncedCallback from './actions/actionsSyncedCallback';\n\ninterface Event<T> {\n  change: Spec<T>;\n  id?: number;\n  error?: undefined;\n}\n\ninterface ApiError {\n  error: string;\n  id?: number;\n}\n\nfunction isError(m: Event<unknown> | ApiError): m is ApiError {\n  return m.error !== undefined;\n}\n\nexport default class SharedReducer<T> {\n  private connection: WebSocketConnection;\n\n  private latestServerState?: T;\n\n  private latestLocalState?: T;\n\n  private currentChange?: Spec<T>;\n\n  private currentSyncCallbacks: SyncCallback<T>[] = [];\n\n  private localChanges: Event<T>[] = [];\n\n  private syncCallbacks = new Map<number, SyncCallback<T>[]>();\n\n  private pendingChanges: SpecSource<T>[] = [];\n\n  private isDispatching = false;\n\n  private idCounter = 0;\n\n  public constructor(\n    wsUrl: string,\n    token: string | undefined = undefined,\n    private readonly changeCallback: ((state: T) => void) | undefined = undefined,\n    errorCallback: ((error: string) => void) | undefined = undefined,\n    private readonly warningCallback: ((error: string) => void) | undefined = undefined,\n  ) {\n    this.connection = new WebSocketConnection(\n      wsUrl,\n      token,\n      this.handleMessage,\n      errorCallback,\n    );\n  }\n\n  public close(): void {\n    this.connection.close();\n    this.latestServerState = undefined;\n    this.latestLocalState = undefined;\n    this.currentChange = undefined;\n    this.currentSyncCallbacks = [];\n    this.localChanges = [];\n    this.syncCallbacks.clear();\n    this.pendingChanges = [];\n  }\n\n  public dispatch: Dispatch<T> = (specs) => {\n    if (!specs || !specs.length) {\n      return;\n    }\n\n    if (this.isDispatching) {\n      throw new Error('Cannot dispatch recursively');\n    }\n\n    const oldState = this.getState();\n    if (oldState === undefined) {\n      this.pendingChanges.push(...specs);\n    } else {\n      const state = this.internalApply(oldState, specs);\n      if (state !== oldState) {\n        this.changeCallback?.(state);\n      }\n    }\n  };\n\n  public addSyncCallback(callback: SyncCallback<T>): void {\n    this.dispatch([actionsSyncedCallback(callback)]);\n  }\n\n  public getState(): T | undefined {\n    if (!this.latestLocalState && this.latestServerState) {\n      this.latestLocalState = this.internalLocalStateFromServerState(this.latestServerState);\n    }\n    return this.latestLocalState;\n  }\n\n  private internalLocalStateFromServerState(serverState: T): T {\n    let state = update(\n      serverState,\n      combine(this.localChanges.map(({ change }) => change)),\n    );\n    if (this.currentChange) {\n      state = update(state, this.currentChange);\n    }\n    return state;\n  }\n\n  private internalGetUniqueId(): number {\n    this.idCounter += 1;\n    return this.idCounter;\n  }\n\n  private internalSend = (): void => {\n    if (this.currentChange === undefined) {\n      return;\n    }\n\n    const event = {\n      change: this.currentChange,\n      id: this.internalGetUniqueId(),\n    };\n    this.localChanges.push(event);\n    if (this.currentSyncCallbacks.length > 0) {\n      this.syncCallbacks.set(event.id, this.currentSyncCallbacks);\n      this.currentSyncCallbacks = [];\n    }\n    this.connection.send(event);\n    this.currentChange = undefined;\n  };\n\n  private internalApply(oldState: T, changes: SpecSource<T>[]): T {\n    this.isDispatching = true;\n    const { state, delta } = reduce(oldState, changes, (syncCallback, curState) => {\n      if (curState === oldState && !this.currentChange) {\n        syncCallback(oldState);\n      } else {\n        this.currentSyncCallbacks.push(syncCallback);\n      }\n    });\n    this.isDispatching = false;\n\n    if (state !== oldState) {\n      this.latestLocalState = state;\n      if (!this.currentChange) {\n        this.currentChange = delta;\n        setTimeout(this.internalSend, 0);\n      } else {\n        this.currentChange = combine<T>([this.currentChange, delta]);\n      }\n    }\n    return state;\n  }\n\n  private handleMessage = (data: unknown): void => {\n    const message = data as Event<T> | ApiError;\n\n    const index = (message.id === undefined) ?\n      -1 : this.localChanges.findIndex((c) => (c.id === message.id));\n    if (index !== -1) {\n      this.localChanges.splice(index, 1);\n    }\n\n    let changed = true;\n    if (isError(message)) {\n      this.warningCallback?.(`Update failed: ${message.error}`);\n    } else {\n      if (index === 0) {\n        // removed the oldest pending change and applied it to the base\n        // server state: nothing has changed\n        changed = false;\n      }\n      this.latestServerState = update(\n        this.latestServerState || ({} as T),\n        message.change,\n      );\n    }\n\n    if (changed) {\n      this.latestLocalState = undefined;\n    }\n    let state = this.getState();\n    if (this.pendingChanges.length && state !== undefined) {\n      const newState = this.internalApply(state, this.pendingChanges);\n      if (newState !== state) {\n        state = newState;\n        changed = true;\n      }\n      this.pendingChanges.length = 0;\n    }\n    if (changed && state !== undefined) {\n      this.changeCallback?.(state);\n    }\n    if (message.id !== undefined) {\n      const callbacks = this.syncCallbacks.get(message.id);\n      if (callbacks) {\n        this.syncCallbacks.delete(message.id);\n        const fixedState = state;\n        if (fixedState === undefined) {\n          throw new Error('Did not receive initial state from server');\n        }\n        callbacks.forEach((fn) => fn(fixedState));\n      }\n    }\n  };\n}\n","import { update, combine, Spec } from 'json-immutability-helper';\nimport type { SpecSource, SyncCallback } from './DispatchSpec';\n\ninterface StackFrame<T> {\n  vs: T[];\n  i: number;\n  prev: StackFrame<T> | null;\n}\n\nfunction iterateStack<T>(\n  initial: T[],\n  fn: (v: T) => T[] | null | undefined,\n): void {\n  let cur: StackFrame<T> | null = { vs: initial, i: 0, prev: null };\n  while (cur) {\n    if (cur.i >= cur.vs.length) {\n      cur = cur.prev;\n    } else {\n      const next = fn(cur.vs[cur.i]);\n      cur.i += 1;\n      if (next && next.length) {\n        cur = { vs: next, i: 0, prev: cur };\n      }\n    }\n  }\n}\n\ninterface ReductionResult<T> {\n  state: T;\n  delta: Spec<T>;\n}\n\nexport default function reduce<T>(\n  oldState: T,\n  baseChanges: SpecSource<T>[],\n  registerSyncCallback: (fn: SyncCallback<T>, currentState: T) => void,\n): ReductionResult<T> {\n  let state: T = oldState;\n\n  const allChanges: Spec<T>[] = [];\n  const aggregate: Spec<T>[] = [];\n  function applyAggregate(): void {\n    if (aggregate.length > 0) {\n      const combinedChange = combine<T>(aggregate);\n      allChanges.push(combinedChange);\n      state = update(state, combinedChange);\n      aggregate.length = 0;\n    }\n  }\n\n  iterateStack(baseChanges, (change) => {\n    if (typeof change === 'function') {\n      applyAggregate();\n      if (change.afterSync) {\n        registerSyncCallback(change, state);\n        return null;\n      }\n      return change(oldState);\n    }\n    if (change) {\n      aggregate.push(change);\n    }\n    return null;\n  });\n  applyAggregate();\n  return { state, delta: combine<T>(allChanges) };\n}\n"],"sourceRoot":""}